#!/usr/bin/env python3

# build_assistant.py
#
# (C) Copyright 2014-present  Cristian Dinu <goc9000@gmail.com>
#
# This file is part of Uniarchive II.
#
# Licensed under the GPL-3

import argparse
import os
import re
import sys
import yaml

from collections import namedtuple

from build_assistant.VirtualPath import VirtualPath
from build_assistant.AutoGeneratedSource import AutoGeneratedSource, CodeGenConfig


AppMetadata = namedtuple('AppMetadata', ['app_name', 'copyright_text', 'license_text'])
EnumConfig = namedtuple('EnumConfig', ['values', 'internal_comment'])
EnumValue = namedtuple('EnumValue', ['text', 'constant', 'int_value', 'comment'])


APP_METADATA = AppMetadata(
    app_name='UniArchive II',
    copyright_text='(C) Copyright 2014-present  Cristian Dinu <goc9000@gmail.com>',
    license_text='Licensed under the GPL-3',
)

CODE_GEN_CFG = CodeGenConfig(
    app_metadata=APP_METADATA,
    indent_size=4,
    gutter_width=120,
    base_namespace='uniarchive2',
)

BASE_SRC_DIR = VirtualPath.from_text('src')


def camelcase_to_underscore(name):
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)).lower()


def classname_to_varname(name):
    return camelcase_to_underscore(name).split('_')[-1]


def gen_enums(config):
    def text_to_constant_name(text):
        return '_'.join(word.upper() for word in re.findall('[a-z0-9]+', text, flags=re.IGNORECASE))

    def parse_enum_value(value_config):
        PATTERN = ''.join(['^', '(.*?)', '(?:\s+as\s+([A-Z_]+))?', '(?:\s*=\s*(\d+))?', '(?:\s*//\s*(.*))?', '$'])
        match = re.match(PATTERN, value_config)
        assert match is not None

        text, constant, int_value, comment = match.groups()

        return EnumValue(
            text=text,
            constant=constant or text_to_constant_name(text),
            int_value=int_value,
            comment=comment
        )

    def parse_enum_config(enum_config):
        values = list()
        options = dict()

        for subconfig in enum_config:
            if isinstance(subconfig, str):
                values.append(parse_enum_value(subconfig))
            else:
                options.update(**subconfig)

        return EnumConfig(
            values=values,
            internal_comment=options.get('internal comment')
        )

    def gen_enum(name, path, enum_config):
        enum_info = parse_enum_config(enum_config)

        varname = classname_to_varname(name)
        parameter_spec = name + ' ' + varname

        name_for_function = 'name_for_' + camelcase_to_underscore(name)

        h_source = AutoGeneratedSource(path, name, 'h', CODE_GEN_CFG)\
            .qt_include('QDebug')

        cpp_source = AutoGeneratedSource(path, name, 'cpp', CODE_GEN_CFG)\
            .include('utils/qt/shortcuts.h')\
            .qt_include('QtDebug')

        if enum_info.internal_comment is not None:
            h_source.line_comment(enum_info.internal_comment).nl()

        with h_source.enum_class_block(name) as block:
            for i, value in enumerate(enum_info.values):
                line = value.constant

                if value.int_value is not None:
                    line += ' = ' + value.int_value

                line += ','

                if value.comment is not None:
                    line += ' // ' + value.comment

                block.line(line)

        h_source.declare_fn(name_for_function, 'QString', parameter_spec)
        with cpp_source.function(name_for_function, 'QString', parameter_spec) as fn:
            with fn.switch_block(varname) as sw:
                for value in enum_info.values:
                    with sw.case_block(name + '::' + value.constant) as c:
                        c.line('return {0};'.format(c.string_literal(value.text)))

            fn.line('invariant_violation("Invalid {0} value (%d)", {1});'.format(name, varname))

        h_source.nl().declare_fn('operator<< ', 'QDebug', 'QDebug stream', parameter_spec)
        with cpp_source.function('operator<< ', 'QDebug', 'QDebug stream', parameter_spec) as fn:
            fn.line('stream << QP({0}({1}));'.format(name_for_function, varname))\
              .nl()\
              .line('return stream;')

        h_source.commit(BASE_SRC_DIR)
        cpp_source.commit(BASE_SRC_DIR)

    def gen_enums_rec(config_view, base_path):
        for yaml_path, subconfig in config_view.items():
            path = VirtualPath.from_text(yaml_path)

            basename = path.basename()

            if basename[0].isupper():
                gen_enum(basename, base_path.append(path.parent()), subconfig)
            else:
                gen_enums_rec(subconfig, base_path.append(path))

    gen_enums_rec(config['enums'], VirtualPath([]))


def autogenerate_code():
    with open('autogen_config.yml', 'r') as f:
        config = yaml.load(f)

    assert os.path.isdir(BASE_SRC_DIR.realize())

    gen_enums(config)


def main():
    parser = argparse.ArgumentParser(description='Build assistant for Uniarchive II')

    subparsers = parser.add_subparsers(title='commands', dest='command')

    subparsers.add_parser('gencode', help='Build autogenerated code')

    raw_args = parser.parse_args(sys.argv[1:])

    if raw_args.command is None:
        parser.print_usage()
        return

    if raw_args.command == 'gencode':
        autogenerate_code()

main()
