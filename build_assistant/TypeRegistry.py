# build_assistant/TypeRegistry.py
#
# (C) Copyright 2014-present  Cristian Dinu <goc9000@gmail.com>
#
# This file is part of Uniarchive II.
#
# Licensed under the GPL-3

import re

from enum import Enum
from collections import namedtuple

from build_assistant.VirtualPath import VirtualPath
from build_assistant.autogen_common import get_full_autogen_raw_event_path_and_name
from build_assistant.util import scan_files


TypeKind = Enum('TypeKind', ['POLYMORPHIC', 'MOVABLE', 'HEAVY', 'PRIMITIVE'])
TypeInfo = namedtuple('TypeInfo', ['kind', 'include', 'qt_include', 'use'])


class TypeRegistry:
    types = None

    def __init__(self, types):
        self.types = dict(types)

    def lookup(self, type):
        if type in self.types:
            return self.types[type]

        if re.match(r'^Q[A-Z].*', type):
            return TypeInfo(
                kind=TypeKind.HEAVY,
                include=None,
                qt_include=type,
                use=None,
            )
        else:
            return TypeInfo(
                kind=TypeKind.HEAVY if re.match(r'^[A-Z].*', type) else TypeKind.PRIMITIVE,
                include=None,
                qt_include=None,
                use=None,
            )

    @staticmethod
    def build(base_src_dir, autogen_config, code_gen_cfg):
        def is_type_file(path):
            return re.match(r'^[A-Z][A-Za-z0-9_]*[.]h$', path.basename())

        def extract_namespace_from_file(content):
            match = re.search(r'\b((?:namespace\s+[A-Za-z0-9_]+\s*\{\s*)+)', content, re.MULTILINE)
            if match is None:
                return None

            return VirtualPath([part[10:].strip() for part in match.group(0).split('{')[:-1]])

        def physical_path(path, name):
            return VirtualPath(item.strip('()') for item in path.elements).add(name + '.h')

        def namespace_path(path):
            return VirtualPath([code_gen_cfg.base_namespace] + [x for x in path.elements if not x.startswith('(')])

        type_registry = dict()

        actual_files = scan_files(base_src_dir, full_paths=False, filter=is_type_file)
        for path in actual_files:
            typename = path.basename()[:-2]  # Strip the .h

            with open(path.prepend(base_src_dir).realize(), 'rt') as f:
                content = f.read()

            # For now we use these manual haxx
            if len(path.elements) > 2 and path.elements[0] == 'intermediate_format' and\
                path.elements[1] in ['content', 'events', 'provenance', 'subjects'] and typename != 'RawMessageContent':
                kind = TypeKind.POLYMORPHIC
            elif typename == 'RawMessageContent':
                kind = TypeKind.MOVABLE
            else:
                kind = TypeKind.HEAVY

            type_registry[typename] = TypeInfo(
                kind=kind,
                include=path,
                qt_include=None,
                use=extract_namespace_from_file(content),
            )

        # Now add the autogenerated types
        for path, name, _ in autogen_config.enums:
            type_registry[name] = TypeInfo(
                kind=TypeKind.PRIMITIVE,
                include=physical_path(path, name),
                qt_include=None,
                use=namespace_path(path),
            )
        for path, name, _ in autogen_config.raw_events:
            path, name = get_full_autogen_raw_event_path_and_name(path, name)
            type_registry[name] = TypeInfo(
                kind=TypeKind.POLYMORPHIC,
                include=physical_path(path, name),
                qt_include=None,
                use=namespace_path(path),
            )

        return TypeRegistry(type_registry)
