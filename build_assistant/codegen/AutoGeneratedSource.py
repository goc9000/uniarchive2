# build_assistant/codegen/AutoGeneratedSource.py
#
# (C) Copyright 2014-present  Cristian Dinu <goc9000@gmail.com>
#
# This file is part of Uniarchive II.
#
# Licensed under the GPL-3

import re

from collections import namedtuple

from build_assistant.autogen_common import HASH_LINE_PREFIX, BEGIN_CUSTOM_SECTION_LINE_PREFIX, compute_content_hash
from build_assistant.codegen.TopLevelCodeSection import TopLevelCodeSection
from build_assistant.codegen.codegen_utils import filter_lines
from build_assistant.includes import IncludeType, UseType, normalize_include_path, normalize_use_path
from build_assistant.util.VirtualPath import VirtualPath


CodeGenConfig = namedtuple('CodeGenConfig', ['app_metadata', 'indent_size', 'gutter_width', 'base_namespace'])


class AutoGeneratedSource:
    virtual_path = None
    name = None
    type = None

    include_banks = None
    use_banks = None

    used_symbols = None
    manually_covered_symbols = None
    sources_covering_symbols = None

    code = None

    custom_sections = None

    companion = None

    core = None

    def __init__(self, virtual_path, name, type, autogen_core, companion=None):
        self.virtual_path = virtual_path
        self.name = name
        self.type = type

        self.core = autogen_core

        self.include_banks = {
            IncludeType.LOCAL: list(),
            IncludeType.STD: list(),
            IncludeType.QT: list(),
        }
        self.use_banks = {
            UseType.LOCAL: list(),
            UseType.STD: list(),
        }

        self.code = TopLevelCodeSection(self)

        self.used_symbols = set()
        self.manually_covered_symbols = set()
        self.sources_covering_symbols = list()
        self.custom_sections = set()

        self.companion = companion
        if companion is not None:
            self.sources_covering_symbols.append(companion)

        if type == 'cpp':
            self.include_banks[IncludeType.LOCAL].append(self.physical_path().replace_basename(name + '.h'))

    # Custom sections

    def get_custom_sections(self):
        return self.custom_sections.copy()

    # Includes

    def include(self, *items):
        return self.include_programmatic(IncludeType.LOCAL, *items)

    def std_include(self, *items):
        return self.include_programmatic(IncludeType.STD, *items)

    def qt_include(self, *items):
        return self.include_programmatic(IncludeType.QT, *items)

    def use(self, *items):
        return self.use_programmatic(UseType.LOCAL, *items)

    def std_use(self, *items):
        return self.use_programmatic(UseType.STD, *items)

    def include_programmatic(self, bank, *items):
        for path in map(normalize_include_path, items):
            if bank == IncludeType.LOCAL and path == self.physical_path():
                continue
            if path in self.include_banks[bank]:
                continue

            self.include_banks[bank].append(path)

        return self

    def use_programmatic(self, bank, *items):
        for path in map(normalize_use_path, items):
            if bank == UseType.LOCAL and path.is_equal_or_parent_of(VirtualPath(self.namespace_path())):
                continue
            if path in self.use_banks[bank]:
                continue

            self.use_banks[bank].append(path)

        return self

    # Symbols

    def use_symbol(self, symbol):
        for part in re.split(r'[^A-Za-z0-9_]+', symbol):
            if part != '':
                self.used_symbols.add(part)

        return self

    def use_symbols(self, *symbols):
        for symbol in symbols:
            self.use_symbol(symbol)

        return self

    def cover_symbols(self, symbols):
        self.manually_covered_symbols |= set(symbols)
        return self

    def cover_symbols_from(self, source):
        if not source in self.sources_covering_symbols:
            self.sources_covering_symbols.append(source)

        return self

    def get_covered_symbols(self):
        _, _, covered_symbols = self._includes_uses_and_covered_symbols()
        return covered_symbols

    def _effective_includes_and_uses(self):
        includes, uses, _ = self._includes_uses_and_covered_symbols()
        return includes, uses

    def _symbols_covered_by_includes(self, includes):
        covered_symbols = set()

        for bank, items in includes.items():
            for item in items:
                covered_symbols |= set(self.core.symbol_registry.symbols_covered_by_include(bank, item))

        return covered_symbols

    def _includes_uses_and_covered_symbols(self):
        covered_symbols = self.manually_covered_symbols | self._symbols_covered_by_includes(self.include_banks)
        for source in self.sources_covering_symbols:
            covered_symbols |= source.get_covered_symbols()

        includes = {bank: items.copy() for bank, items in self.include_banks.items()}
        uses = {bank: items.copy() for bank, items in self.use_banks.items()}

        for first_pass in [True, False]:
            for symbol in self.used_symbols:
                if symbol in covered_symbols:
                    continue

                symbol_info = self.core.symbol_registry.lookup(symbol)

                if symbol_info.include is not None:
                    bank, path = symbol_info.include

                    if first_pass and bank != IncludeType.LOCAL:
                        # We try to cover as much as possible with local includes only, in the first pass
                        continue

                    if not ((path in includes[bank]) or (bank == IncludeType.LOCAL and path == self.physical_path())):
                        includes[bank].append(path)

                if symbol_info.use is not None:
                    bank, path = symbol_info.use
                    if not (
                        (path in uses[bank]) or
                        (bank == UseType.LOCAL and path.is_equal_or_parent_of(VirtualPath(self.namespace_path())))
                    ):
                        uses[bank].append(path)

            covered_symbols |= self._symbols_covered_by_includes(includes)

        return includes, uses, covered_symbols

    # Misc info

    def physical_path(self):
        return VirtualPath(item.strip('()') for item in self.virtual_path.elements).add(self.name + '.' + self.type)

    def namespace_path(self):
        return [self.core.codegen_cfg.base_namespace] + [x for x in self.virtual_path.elements if not x.startswith('(')]

    # Generation

    def generated_content(self, custom_sections=None):
        return "\n".join(self._gen_lines(custom_sections=custom_sections)) + "\n"

    def _gen_header_lines(self):
        def gen_lines_real():
            yield self.physical_path().to_text()
            yield ''

            if len(self.custom_sections) > 0:
                yield 'WARNING: This file is partially autogenerated. ' + \
                      'Edit only the custom sections, or autogen_config.yml and re-generate.'
            else:
                yield 'WARNING: This file is autogenerated. ' + \
                      'To make changes, edit autogen_config.yml instead and re-generate.'
            yield HASH_LINE_PREFIX[3:]
            yield ''

            yield self.core.codegen_cfg.app_metadata.copyright_text
            yield ''
            yield 'This file is part of {0}.'.format(self.core.codegen_cfg.app_metadata.app_name)
            yield ''
            yield self.core.codegen_cfg.app_metadata.license_text

        yield '/**'
        for line in gen_lines_real():
            yield ' * ' + line if line != '' else ' *'
        yield ' */'

    def _gen_includes_lines(self, includes):
        for bank in [IncludeType.LOCAL, IncludeType.QT, IncludeType.STD]:
            if len(includes[bank]) == 0:
                continue

            sort_law = self._local_includes_sort_law if bank == IncludeType.LOCAL else lambda path: path.to_text()

            for item in sorted(includes[bank], key=sort_law):
                yield ('#include ' + ('"{0}"' if bank == IncludeType.LOCAL else '<{0}>')).format(item)

            yield ''

    def _local_includes_sort_law(self, path):
        if path == self.physical_path():
            return 0,  # corresponding header file always comes first
        else:
            return (1,) + tuple((0, item) for item in path.elements[:-1]) + ((1, path.elements[-1]),)

    def _gen_uses_lines(self, uses):
        for bank in [UseType.STD, UseType.LOCAL]:
            for item in sorted(uses[bank], key=lambda path: path.to_text()):
                yield 'using namespace {0};'.format('::'.join(item.elements))

        yield ''

    def _gen_namespaced_lines(self, uses):
        for line in self._gen_uses_lines(uses):
            yield line

        for line in self.code.gen_lines(0):
            yield line

    def _gen_guarded_lines(self):
        includes, uses = self._effective_includes_and_uses()

        for line in self._gen_includes_lines(includes):
            yield line

        yield ''
        namespace_decls = ['namespace {0} {{'.format(namespace) for namespace in self.namespace_path()]
        yield ' '.join(namespace_decls)
        yield ''

        for line in self._gen_namespaced_lines(uses):
            yield line

        yield ''
        yield '}' * len(namespace_decls)

    def _gen_guards(self, guarded_lines):
        guard_name = '_'.join(self.namespace_path() + [self.name, 'h']).upper()

        yield '#ifndef ' + guard_name
        yield '#define ' + guard_name
        yield ''

        for line in guarded_lines:
            yield line

        yield ''
        yield '#endif //' + guard_name

    def _gen_body_lines(self):
        guarded_lines = self._gen_guarded_lines()

        for line in self._gen_guards(guarded_lines) if self.type == 'h' else guarded_lines:
            yield line

    def _gen_unfiltered_lines(self):
        for line in self._gen_header_lines():
            yield line

        yield ''

        for line in self._gen_body_lines():
            yield line

    def _gen_lines_without_hash(self):
        for line in filter_lines(self._gen_unfiltered_lines()):
            yield line

    def _gen_lines(self, custom_sections=None):
        custom_sections = custom_sections or dict()
        content_hash = compute_content_hash(self._gen_lines_without_hash())

        for line in self._gen_lines_without_hash():
            if line.startswith(HASH_LINE_PREFIX):
                yield line + ' ' + content_hash
            elif line.strip().startswith(BEGIN_CUSTOM_SECTION_LINE_PREFIX):
                section_name = line.strip()[len(BEGIN_CUSTOM_SECTION_LINE_PREFIX):]
                yield line
                if section_name in custom_sections:
                    for section_line in custom_sections[section_name]:
                        yield section_line
            else:
                yield line
