# build_assistant/SymbolRegistry.py
#
# (C) Copyright 2014-present  Cristian Dinu <goc9000@gmail.com>
#
# This file is part of Uniarchive II.
#
# Licensed under the GPL-3

import re

from enum import Enum
from collections import namedtuple

from build_assistant.VirtualPath import VirtualPath
from build_assistant.autogen_common import get_full_autogen_raw_event_path_and_name
from build_assistant.includes import IncludeType, local_include, std_include, qt_include, local_use, std_use, \
    normalize_include_path
from build_assistant.util import scan_files


TypeKind = Enum('TypeKind', ['POLYMORPHIC', 'MOVABLE', 'HEAVY', 'PRIMITIVE'])
SymbolInfo = namedtuple('SymbolInfo', ['is_type', 'type_kind', 'include', 'use'])


SHORTCUTS = ['IMM', 'CPTR', 'TAKE', 'TAKE_VEC']


class SymbolRegistry:
    symbols = None

    def __init__(self, symbols):
        self.symbols = dict(**symbols, **get_builtin_symbols())

    def lookup(self, symbol):
        if symbol in self.symbols:
            return self.symbols[symbol]

        if looks_like_qt_symbol(symbol):
            return SymbolInfo(
                is_type=True,
                type_kind=TypeKind.HEAVY,
                include=qt_include(symbol),
                use=None,
            )
        else:
            return SymbolInfo(
                is_type=True,
                type_kind=TypeKind.HEAVY if re.match(r'^[A-Z].*', symbol) else TypeKind.PRIMITIVE,
                include=None,
                use=None,
            )

    def symbols_covered_by_include(self, bank, path):
        path = normalize_include_path(path)

        if bank == IncludeType.QT and looks_like_qt_symbol(path.to_text()):
            return [path.to_text()]

        symbols = list()

        for symbol, symbol_info in self.symbols.items():
            if symbol_info.include == (bank, path):
                symbols.append(symbol)

        return symbols

    @staticmethod
    def build(base_src_dir, autogen_config, code_gen_cfg):
        def is_type_file(path):
            return re.match(r'^[A-Z][A-Za-z0-9_]*[.]h$', path.basename())

        def extract_namespace_from_file(content):
            match = re.search(r'\b((?:namespace\s+[A-Za-z0-9_]+\s*\{\s*)+)', content, re.MULTILINE)
            if match is None:
                return None

            return VirtualPath([part[10:].strip() for part in match.group(0).split('{')[:-1]])

        def physical_path(path, name):
            return VirtualPath(item.strip('()') for item in path.elements).add(name + '.h')

        def namespace_path(path):
            return VirtualPath([code_gen_cfg.base_namespace] + [x for x in path.elements if not x.startswith('(')])

        symbols = dict()

        actual_files = scan_files(base_src_dir, full_paths=False, filter=is_type_file)
        for path in actual_files:
            typename = path.basename()[:-2]  # Strip the .h

            with open(path.prepend(base_src_dir).realize(), 'rt') as f:
                content = f.read()
            namespace = extract_namespace_from_file(content)

            # For now we use these manual haxx
            if len(path.elements) > 2 and path.elements[0] == 'intermediate_format' and\
                path.elements[1] in ['content', 'events', 'provenance', 'subjects'] and typename != 'RawMessageContent':
                kind = TypeKind.POLYMORPHIC
            elif typename == 'RawMessageContent':
                kind = TypeKind.MOVABLE
            else:
                kind = TypeKind.HEAVY

            symbols[typename] = SymbolInfo(
                is_type=True,
                type_kind=kind,
                include=local_include(path),
                use=local_use(namespace) if namespace is not None else None,
            )

        # Now add the autogenerated types
        for path, name, _ in autogen_config.enums:
            symbols[name] = SymbolInfo(
                is_type=True,
                type_kind=TypeKind.PRIMITIVE,
                include=local_include(physical_path(path, name)),
                use=local_use(namespace_path(path)),
            )
        for path, name, _ in autogen_config.raw_events:
            path, name = get_full_autogen_raw_event_path_and_name(path, name)
            symbols[name] = SymbolInfo(
                is_type=True,
                type_kind=TypeKind.POLYMORPHIC,
                include=local_include(physical_path(path, name)),
                use=local_use(namespace_path(path)),
            )

        return SymbolRegistry(symbols)


def get_builtin_symbols():
    symbols = dict(
        unique_ptr=SymbolInfo(
            is_type=False,
            type_kind=None,
            include=std_include('memory'),
            use=std_use('std'),
        ),
        vector=SymbolInfo(
            is_type=False,
            type_kind=None,
            include=std_include('vector'),
            use=std_use('std'),
        ),
        optional=SymbolInfo(
            is_type=False,
            type_kind=None,
            include=local_include('utils/external_libs/optional.hpp'),
            use=std_use('std::experimental'),
        ),
    )

    for symbol in SHORTCUTS:
        symbols[symbol] = SymbolInfo(
            is_type=False,
            type_kind=None,
            include=local_include('utils/language/shortcuts.h'),
            use=None,
        )

    return symbols


def looks_like_qt_symbol(symbol):
    return re.match(r'^Q[A-Z].*', symbol) is not None
