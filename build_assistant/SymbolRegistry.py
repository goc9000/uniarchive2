# build_assistant/SymbolRegistry.py
#
# (C) Copyright 2014-present  Cristian Dinu <goc9000@gmail.com>
#
# This file is part of Uniarchive II.
#
# Licensed under the GPL-3

import re

from enum import Enum
from collections import namedtuple

from build_assistant.VirtualPath import VirtualPath
from build_assistant.autogen_common import get_full_autogen_raw_event_path_and_name
from build_assistant.util import scan_files


TypeKind = Enum('TypeKind', ['POLYMORPHIC', 'MOVABLE', 'HEAVY', 'PRIMITIVE'])
SymbolInfo = namedtuple('SymbolInfo', ['is_type', 'type_kind', 'include', 'use'])


SHORTCUTS = ['IMM', 'CPTR', 'TAKE', 'TAKE_VEC']


class SymbolRegistry:
    symbols = None

    def __init__(self, symbols):
        self.symbols = dict(**symbols, **get_builtin_symbols())

    def lookup(self, symbol):
        if symbol in self.symbols:
            return self.symbols[symbol]

        if re.match(r'^Q[A-Z].*', symbol):
            return SymbolInfo(
                is_type=True,
                type_kind=TypeKind.HEAVY,
                include=('qt', symbol),
                use=None,
            )
        else:
            return SymbolInfo(
                is_type=True,
                type_kind=TypeKind.HEAVY if re.match(r'^[A-Z].*', symbol) else TypeKind.PRIMITIVE,
                include=None,
                use=None,
            )

    @staticmethod
    def build(base_src_dir, autogen_config, code_gen_cfg):
        def is_type_file(path):
            return re.match(r'^[A-Z][A-Za-z0-9_]*[.]h$', path.basename())

        def extract_namespace_from_file(content):
            match = re.search(r'\b((?:namespace\s+[A-Za-z0-9_]+\s*\{\s*)+)', content, re.MULTILINE)
            if match is None:
                return None

            return VirtualPath([part[10:].strip() for part in match.group(0).split('{')[:-1]])

        def physical_path(path, name):
            return VirtualPath(item.strip('()') for item in path.elements).add(name + '.h')

        def namespace_path(path):
            return VirtualPath([code_gen_cfg.base_namespace] + [x for x in path.elements if not x.startswith('(')])

        symbols = dict()

        actual_files = scan_files(base_src_dir, full_paths=False, filter=is_type_file)
        for path in actual_files:
            typename = path.basename()[:-2]  # Strip the .h

            with open(path.prepend(base_src_dir).realize(), 'rt') as f:
                content = f.read()

            # For now we use these manual haxx
            if len(path.elements) > 2 and path.elements[0] == 'intermediate_format' and\
                path.elements[1] in ['content', 'events', 'provenance', 'subjects'] and typename != 'RawMessageContent':
                kind = TypeKind.POLYMORPHIC
            elif typename == 'RawMessageContent':
                kind = TypeKind.MOVABLE
            else:
                kind = TypeKind.HEAVY

            symbols[typename] = SymbolInfo(
                is_type=True,
                type_kind=kind,
                include=path,
                use=extract_namespace_from_file(content),
            )

        # Now add the autogenerated types
        for path, name, _ in autogen_config.enums:
            symbols[name] = SymbolInfo(
                is_type=True,
                type_kind=TypeKind.PRIMITIVE,
                include=physical_path(path, name),
                use=namespace_path(path),
            )
        for path, name, _ in autogen_config.raw_events:
            path, name = get_full_autogen_raw_event_path_and_name(path, name)
            symbols[name] = SymbolInfo(
                is_type=True,
                type_kind=TypeKind.POLYMORPHIC,
                include=physical_path(path, name),
                use=namespace_path(path),
            )

        return SymbolRegistry(symbols)


def get_builtin_symbols():
    symbols = dict(
        unique_ptr=SymbolInfo(
            is_type=False,
            type_kind=None,
            include=('std', 'memory'),
            use=('std', 'std'),
        ),
        vector=SymbolInfo(
            is_type=False,
            type_kind=None,
            include=('std', 'vector'),
            use=('std', 'std'),
        ),
        optional=SymbolInfo(
            is_type=False,
            type_kind=None,
            include='utils/external_libs/optional.hpp',
            use=('std', 'std::experimental'),
        ),
    )

    for symbol in SHORTCUTS:
        symbols[symbol] = SymbolInfo(
            is_type=False,
            type_kind=None,
            include='utils/language/shortcuts.h',
            use=None,
        )

    return symbols
